# 동기화

## 동시성 문제
- 여러 스레드가 공유 자원을 동시에 수정하려 할 때 발생하는 데이터의 일관성 문제, 경합 조건(race condition)이라고도 부름
- 여러 스레드에서 동시에 읽기만 하는 경우에는 일반적으로 문제가 발생하지 않음
- 공유 자원(Shared Resource): 여러 스레드에서 접근하고 수정할 수 있는 자원
- 임계 영역(Critical Section): 공유 자원의 수정을 시도하는 코드 영역, 이 영역에서는 동시 접근을 방지하여 데이터의 무결성을 유지해야 함

<br>

## `synchronized`
- `synchronized` 키워드를 사용해 임계 영역을 보호하면 여러 스레드가 동시에 하나의 공유 자원에 접근하지 못하며, 이를 동기화라 부름
- 모든 객체는 내부에 자신만의 락(lock)을 가짐
- 특정 메소드나 블록을 `synchronized` 키워드로 감싸면, 한 스레드가 락을 획득해 해당 영역의 코드를 실행하는 동안 다른 스레드는 `BLOCKED` 상태로 락을 기다림
- 메소드 레벨에 `synchronized` 키워드를 사용해 동기화하는 것보다는 필요한 부분만 `synchronized` 블록으로 선언하는 것이 성능상 유리함

```java
// 메서드 레벨
public synchronized void method() {}

public void method() {
    // 필요한 부분만
    synchronized(this) {
	      // ...   
    }
}
```

> **참고**  
> `volatile` 키워드 없이 `synchronized` 키워드만 사용해도 메모리 가시성 문제는 발생하지 않음

### 단점
- `BLOCKED` 상태로 대기: 락을 획득하기 위해 무한 대기 상태로 들어가며, 이때 CPU 스케줄링 대상에서 제외됨
- 락 획득 순서 미보장: 락을 획득하기 위해 기다리는 스레드들의 락 획득 순서는 보장되지 않음(누가 먼저 락을 얻을지 예측할 수 없음)