# 컬렉션 프레임워크 - List
## 리스트(List)
- 순서가 있고, 중복을 허용하는 자료 구조
- 공통 기능을 뽑아 인터페이스로 추상화하여 다형성 활용 가능
- 구체적인 `ArrayList` 또는 `LinkedList`에 의존하면 추후 코드 수정 시 비효율적
- `List`에 의존하면 런타임에 구현체 선택 가능
- 클라이언트 클래스는 컴파일 타임에 추상적인 것에 의존하고, 런타임에 의존 관계 주입을 통해 구현체를 주입받아 사용 가능
```java
List<Integer> list1 = new ArrayList<>();
List<Integer> list2 = new LinkedList<>();
```
## 배열 리스트 vs 연결 리스트 성능 비교 - 직접 구현
| 연산 유형       | 배열 리스트 (ArrayList)       | 연결 리스트 (LinkedList)       |
|----------------|-------------------------------|--------------------------------|
| **앞에 추가**   | O(n) - 1369ms                 | O(1) - 2ms                     |
| **앞에 삭제**   | O(n) - 1369ms                 | O(1) - 2ms                     |
| **평균 추가**   | O(n) - 651ms                  | O(n) - 1112ms                  |
| **평균 삭제**   | O(n) - 651ms                  | O(n) - 1112ms                  |
| **뒤에 추가**   | O(1) - 2ms                    | O(n) - 2195ms                  |
| **뒤에 삭제**   | O(1) - 2ms                    | O(n) - 2195ms                  |
| **인덱스 조회** | O(1) - 1ms                    | O(n) - 평균 438ms             |
| **검색**       | O(n) - 평균 115ms            | O(n) - 평균 492ms             |
## 배열 리스트 vs 연결 리스트 성능 비교 - 자바 제공
| 연산 유형       | 배열 리스트 (ArrayList)       | 연결 리스트 (LinkedList)       |
|----------------|-------------------------------|--------------------------------|
| **앞에 추가**   | O(n) - 106ms                  | O(1) - 2ms                     |
| **앞에 삭제**   | O(n) - 106ms                  | O(1) - 2ms                     |
| **평균 추가**   | O(n) - 49ms                   | O(n) - 1116ms                  |
| **평균 삭제**   | O(n) - 49ms                   | O(n) - 1116ms                  |
| **뒤에 추가**   | O(1) - 1ms                    | O(1) - 2ms                     |
| **뒤에 삭제**   | O(1) - 1ms                    | O(1) - 2ms                     |
| **인덱스 조회** | O(1) - 1ms                    | O(n) - 평균 439ms             |
| **검색**       | O(n) - 평균 104ms            | O(n) - 평균 473ms             |
- 자바의 배열 리스트는 데이터 추가 시 메모리 고속 복사를 사용하기 때문에 빠르게 처리 가능
- 이론 상 `LinkedList` 의 중간 삽입 연산은 `ArrayList` 보다 빠를 수 있음
- 실제로는 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향
- `ArrayList`는 요소들이 메모리 상에서 연속적으로 위치하므로 접근 속도가 빠름
- `LinkedList`는 각 요소들이 객체로 존재하며, 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지며 접근 속도가 느려질 수 있음
- `ArrayList`가 실제 사용 환경에서 더 나은 성능을 보일 수 있음
- 대부분의 경우 배열 리스트가 성능상 유리하지만 앞쪽에서 데이터를 추가해야하는 일이 많다면 연결 리스트 사용